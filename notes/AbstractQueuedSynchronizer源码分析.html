<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/277915; Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="951"/>

<div>
<span><div><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/">http://ifeve.com/introduce-abstractqueuedsynchronizer/</a>  讲解的还是不细致。</div><div><br/></div><div><br/></div><div>public final void acquire(int arg) {</div><div>        if (!tryAcquire(arg) &amp;&amp;</div><div>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div>            selfInterrupt();</div><div>    }</div><div><br/></div><div>这里tryAcquire(arg) 是在AQS的子类中进行定义的， 在子类的tryAcquire(arg) 中会通过对AQS提供的一个volatile 关键字修饰的 state， 通过基于该状态判断当前线程是否可以获取资源。如ReentrantLock 中的tryAcquire(1)。</div><div><br/></div><div>ps:首先资源个抽象的概念，AQS提供的只有一个 state 状态， 具体的资源是什么实际上是由使用AQS的类来定义，如ReentrantLock中描述的资源是锁， Semaphore描述的资源是信号量等等。</div><div><br/></div><div><br/></div><div>回到当前话题，当当前线程调用 tryAcquire() 方法返回的是false, 表示获取不到当前的资源， 这时当前线程就会紧接着执行addWaiter(Node.EXCLUSIVE) 方法， <b>AQS提供了 head,   tail 引用</b>，抽象的双向队列，<s>参考CLH锁（这个玩意应该讲解下， 自己当时就是卡在了这里。</s>） <span style="color: rgb(54, 101, 238);">sync队列的特点是AQS维持了head， tail 引用，而AQS 中的节点实际上是在每个线程中的。</span></div><div><br/></div><div><b>理解分析AQS的一个难点就是AQS中采用无锁的双向队列来维护多线程对资源的访问。因此，无锁的队列是如何避免多线程并发问题不容易理解。</b></div><div><br/></div><div><br/></div><div><b>//加入sync 队列</b></div><div>private Node addWaiter(Node mode) { </div><div>        Node node = new Node(Thread.currentThread(), mode);  // node 是线程安全的。</div><div>        // Try the fast path of enq; backup to full enq on failure</div><div>        Node pred = tail;   // 先分配一个引用指向tail</div><div>        if (pred != null) {</div><div>            node.prev = pred;   //将当前节点的 prev  指向 pred（即尾节点）</div><div>            if (compareAndSetTail(pred, node)) {    //如果当前的尾节点没有变化，即被其他线程修改，则设置 tail  为当前的节点。</div><div><br/></div><div>                pred.next = node; //在将node 插入到队列的尾部中的这个操作来说，并非原子性的。</div><div>                return node;</div><div>            }</div><div>        }</div><div><br/></div><div>        enq(node);</div><div>        return node;</div><div>    }</div><div><br/></div><div><br/></div><div>private Node enq(final Node node) {</div><div>        for (;;) {</div><div>            Node t = tail;</div><div>            if (t == null) { // Must initialize</div><div>                <span style="color: rgb(54, 101, 238);">if (compareAndSetHead(new Node()))  //多个线程同时进行双向的队列的初始化，这里可以保证正确的初始化。</span></div><div>                    tail = head;</div><div>            } else {</div><div>                <span style="color: rgb(54, 101, 238);">node.prev = t;</span></div><div><span style="color: rgb(54, 101, 238);">                if (compareAndSetTail(t, node)) { //这两步是原子性的，即能够保证新插入的节点的prev指向的是之前的tail， tail指向新插入的节点。</span></div><div>                    t.next = node;</div><div>                    return t;</div><div>                }</div><div>            }</div><div>        }</div><div>    }</div><div><br/></div><div> final boolean acquireQueued(final Node node, int arg) {</div><div>        boolean failed = true;</div><div>        try {</div><div>            boolean interrupted = false;</div><div>            <span style="color: rgb(54, 101, 238);">for (;;) { //注意这里for循环的作用有两点，1是node.predecessor.waitStatus=SIGNAL,同时阻塞线程。2：线程阻塞或超时中断的时候，在if(p==head &amp;&amp; tryAcquire(arg)) 不满足的情况下，继续阻塞当前线程。</span></div><div>                final Node p = node.predecessor();</div><div>                if (p == head &amp;&amp; tryAcquire(arg)) {<span style="color: rgb(54, 101, 238);">//sync队列中的头结点对应的线程表示正在运行的线程</span></div><div>                    setHead(node);</div><div>                    p.next = null; // help GC</div><div>                    failed = false;</div><div>                    return interrupted;</div><div>                }</div><div>                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div>                    parkAndCheckInterrupt())   <span style="color: rgb(54, 101, 238);">//阻塞当前线程，返回线程是否是由于中断或超时而被唤醒的。LockSupport.unpark(thread) 的中断标志是false， 而中断或超时时中断状态为true。LockSupport.parkNannos(time) 也不会设置中断状态。</span></div><div>                    interrupted = true;</div><div>            }</div><div>        } finally {</div><div>            if (failed)</div><div>                cancelAcquire(node);</div><div>        }</div><div>    }</div><div><br/></div><div><s><span style="color: rgb(255, 0, 0);">//理论上是线程安全的， 但是自己还没有弄清楚，为什么是线程安全的！需要参考canceAcquire方法，实际上cancelAcquire方法并不会修改node.prev, 但会修改node.predecessor.next = node.next (node.next != null) </span></s></div><div>private void setHead(Node node) {</div><div>        <span style="color: rgb(54, 101, 238);">head = node;    // 这是原子性的。因为使用了volatile 进行修饰。</span></div><div>       </div><div>        node.thread = null;  // 目前对于node.thread 和  node.prev 的修改还只是在当前线程中。</div><div>        node.prev = null;</div><div>    }</div><div><br/></div><div><br/></div><div>private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {</div><div>        int ws = pred.waitStatus;</div><div>        if (ws == Node.SIGNAL)</div><div>            /*</div><div>             * This node has already set status asking a release</div><div>             * to signal it, so it can safely park.</div><div>             */</div><div>            return true;</div><div>        if (ws &gt; 0) {</div><div>            /*</div><div>             * Predecessor was cancelled. Skip over predecessors and</div><div>             * indicate retry.</div><div>             */</div><div>            do {</div><div>                node.prev = pred = pred.prev;</div><div>            } while (pred.waitStatus &gt; 0);</div><div>            pred.next = node;  <span style="color: rgb(54, 101, 238);">//pred.next 并不要求是线程安全的。同时可以观察到对对cancel结点的删除分段的。并非线程安全的，但是可以提高程序性能。</span></div><div><b>        }</b> else {</div><div>            /*</div><div>             * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div>             * need a signal, but don't park yet.  Caller will need to</div><div>             * retry to make sure it cannot acquire before parking.</div><div>             */</div><div>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">shouldParkAfterFailedAcquire()  的线程安全性分析？</span></div><div>1: 当前结点对应的线程还在运行中，并没有阻塞，因此当前结点不会被cancel，后面的结点对于cancel结点的删除操作会止步于当前结点。</div><div>2: 我们可能会担心head节点对应的线程在unparkSuccessor() 的时候，由于(h.next == null || h.waitStatus &gt; 0 )的情况下，会从tail 向前访问结点，这个也不会存在问题，因为head节点对应的线程会对唤起的线程进行判断waitStatus &lt;= 0。</div><div><br/></div><div><br/></div><div> private void unparkSuccessor(Node node) {<span style="color: rgb(54, 101, 238);">//unparkSuccessor() 会被cancelAcquire、release、doReleaseShared 三个方法调用。因此分析的时候需要三种不同的调用场景</span></div><div>        /*</div><div>         * If status is negative (i.e., possibly needing signal) try</div><div>         * to clear in anticipation of signalling.  It is OK if this</div><div>         * fails or if status is changed by waiting thread.</div><div>         */</div><div>        int ws = node.waitStatus;</div><div>        if (ws &lt; 0)</div><div>          <b> </b> compareAndSetWaitStatus(node, ws, 0); //  未看懂！！！</div><div><br/></div><div>        /*</div><div>         * Thread to unpark is held in successor, which is normally</div><div>         * just the next node.  But if cancelled or apparently null,</div><div>         * traverse backwards from tail to find the actual</div><div>         * non-cancelled successor.</div><div>         */</div><div>        Node s = node.next;</div><div>        if (s == null || s.waitStatus &gt; 0) {  </div><div>            s = null;</div><div>            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)   //也是跳过取消掉的Node</div><div>                if (t.waitStatus &lt;= 0)</div><div>                    s = t;</div><div>        }</div><div>        if (s != null)</div><div>            LockSupport.unpark(s.thread); // 唤醒等待的线程。</div><div>    }</div><div><br/></div><div><br/></div><div><span style="font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: rgb(255, 255, 255);">回顾整个资源的获取和释放过程：</span><br style="font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/><span style="font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: rgb(255, 255, 255);">在获取时，维护了一个sync队列，<u>每个节点都是一个线程在进行自旋</u>，而依据就是自己是否是首节点的后继并且能够获取资源；</span><br style="font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/><span style="font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: rgb(255, 255, 255);">在释放时，仅仅需要将资源还回去，然后通知一下后继节点并将其唤醒。</span></div><div><span style="font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: rgb(255, 255, 255);">这里需要注意，队列的维护（首节点的更换）是依靠消费者（获取时）来完成的，也就是说在满足了自旋退出的条件时的一刻，这个节点就会被设置成为首节点。</span></div><div><br/></div><div><br/></div><div>private boolean doAcquireNanos(int arg, long nanosTimeout)</div><div>        throws InterruptedException {</div><div>        <b>long lastTime = System.nanoTime();</b></div><div>        final Node node = addWaiter(Node.EXCLUSIVE);</div><div>        boolean failed = true;</div><div>        try {</div><div>            for (;;) {</div><div>                final Node p = node.predecessor();</div><div>                if (p == head &amp;&amp; tryAcquire(arg)) {</div><div>                    setHead(node);</div><div>                    p.next = null; // help GC</div><div>                    failed = false;</div><div>                    return true;</div><div>                }</div><div>              <b>  if (nanosTimeout &lt;= 0)</b></div><div><b>                    return false;</b></div><div>                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div>                  <b>  nanosTimeout &gt; spinForTimeoutThreshold)</b></div><div>                    LockSupport.parkNanos(this, nanosTimeout);</div><div>                <b>long now = System.nanoTime();</b></div><div><b>                nanosTimeout -= now - lastTime;</b></div><div>                <b>lastTime = now;</b></div><div>                if (Thread.interrupted())</div><div>                    throw new InterruptedException();</div><div>            }</div><div>        } finally {</div><div>            if (failed)</div><div>                cancelAcquire(node);</div><div>        }</div><div>    }</div><div><br/></div><div><br/></div><div><br/></div><div>static final class Node {</div><div>        static final Node SHARED = new Node();</div><div>        static final Node EXCLUSIVE = null;</div><div><br/></div><div>        static final int CANCELLED =  1;</div><div>        static final int SIGNAL    = -1;</div><div>        static final int CONDITION = -2;</div><div>        static final int PROPAGATE = -3;</div><div><br/></div><div>        volatile int waitStatus;</div><div>        volatile Node prev;</div><div>        volatile Node next;</div><div>        <span style="color: rgb(54, 101, 238);">volatile Thread thread;   //终于弄清楚了这里为什么要设置为volatile，  在cancelAcquire() 的时候，head.successor这个线程在cancelAcquire() 中设置节点node.thread = null ，但并未设置node.waitStatus = Node.CANCELLED；   即在这两行中间出现了中断，那么当head 对应的线程已经完成了任务，然后唤醒当前节点上的线程执行， 但是当前节点的线程已经被设置为空了，所以在LockSupport.unpark(node.thread) 的时候，并未执行任何的操作。而此时node.successor 应该是被唤醒的。但是head的线程已经唤醒了head.successor 这个线程，所以导致node.successor 这样一直等待下去，这是有问题的。这也就是在cancelAcquire中会有unparkSuccessor(node) 的原因。 </span></div><div><br/></div><div>        Node nextWaiter;   //这里的nextWaiter 并不需要被volatile 关键字修饰，因为condition队列是exclusive</div><div>        final boolean isShared() {</div><div>            return nextWaiter == SHARED;</div><div>        }</div><div><br/></div><div>        final Node predecessor() throws NullPointerException {</div><div>            Node p = prev;</div><div>            if (p == null)</div><div>                throw new NullPointerException();</div><div>            else</div><div>                return p;</div><div>        }</div><div>        Node() {    // Used to establish initial head or SHARED marker</div><div>        }</div><div>        Node(Thread thread, Node mode) {     // Used by addWaiter</div><div>            this.nextWaiter = mode;</div><div>            this.thread = thread;</div><div>        }</div><div>        Node(Thread thread, int waitStatus) { // Used by Condition</div><div>            this.waitStatus = waitStatus;</div><div>            this.thread = thread;</div><div>        }</div><div>    }</div><div><br/></div><div><br/></div><div>关于waitStatus 的取值情况</div><div>/**</div><div>         * Status field, taking on only the values:</div><div>         *   SIGNAL:     The successor of this node is (or will soon be)</div><div>         *               blocked (via park), so the current node must</div><div>         *               unpark its successor when it releases or</div><div>         *               cancels. <span style="color: rgb(54, 101, 238);">To avoid races, acquire methods must</span></div><div><span style="color: rgb(54, 101, 238);">         *               first indicate they need a signal,</span></div><div><span style="color: rgb(54, 101, 238);">         *               then retry the atomic acquire, and then,</span></div><div><span style="color: rgb(54, 101, 238);">         *               on failure, block.  //待研究！！！</span></div><div>         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</div><div>         *               Nodes never leave this state. <span style="color: rgb(54, 101, 238);">In particular,</span></div><div><span style="color: rgb(54, 101, 238);">         *               a thread with cancelled node never again blocks.</span></div><div>         *   CONDITION:  This node is currently on a condition queue.</div><div>         *               It will not be used as a sync queue node</div><div>         *               until transferred, at which time the status</div><div>         *               will be set to 0. (Use of this value here has</div><div>         *               nothing to do with the other uses of the</div><div>         *               field, but simplifies mechanics.)</div><div>         *   PROPAGATE:  A releaseShared should be propagated to other</div><div>         *               nodes. This is set (for head node only) in</div><div>         *               doReleaseShared to ensure propagation</div><div>         *               continues, <span style="color: rgb(54, 101, 238);">even if other operations have</span></div><div><span style="color: rgb(54, 101, 238);">         *               since intervened. //这里的intervened 是什么意思呢？？？？？？</span></div><div>         *   0:          None of the above</div><div>         *</div><div>         * The values are arranged numerically to simplify use.</div><div>         * Non-negative values mean that a node doesn't need to</div><div>         * signal. So, most code doesn't need to check for particular</div><div>         * values, just for sign.</div><div>         *</div><div>         * The field is initialized to 0 for normal sync nodes, and</div><div>         * CONDITION for condition nodes.  It is modified using CAS</div><div>         * (or when possible, unconditional volatile writes).</div><div>         */</div><div>        volatile int waitStatus;</div><div><br/></div><div>        /** Marker to indicate a node is waiting in shared mode */</div><div>        static final Node SHARED = new Node();</div><div>        /** Marker to indicate a node is waiting in exclusive mode */</div><div>        static final Node EXCLUSIVE = null;</div><div><br/></div><div>这里的nextWaiter 有两种值：   EXCLUSIVE,   SHARED  或者是condition队列中的后继结点。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>private void cancelAcquire(Node node) {</div><div>        // Ignore if node doesn't exist</div><div>        if (node == null)</div><div>            return;</div><div><br/></div><div>        <span style="color: rgb(54, 101, 238);">node.thread = null; //注意这里和node.waitStatus = Node.CANCELLED; 之间可能出现中断， 那么这里会造成下面的pred.thread = null 的情况，从而会导致unparkSuccessor(node), 这样是为了防止出现如果pred===hread.  而当前的node </span></div><div><br/></div><div>  <span style="color: rgb(88, 152, 255);">      <span style="color: rgb(54, 101, 238);">// Skip cancelled predecessors</span></span></div><div><span style="color: rgb(54, 101, 238);">        Node pred = node.prev;  </span></div><div><span style="color: rgb(54, 101, 238);">        while (pred.waitStatus &gt; 0)</span></div><div><span style="color: rgb(54, 101, 238);">            node.prev = pred = pred.prev; //这里不用担心后面的线程会和当前的线程就这部分代码产生竟态条件。因为当前节点的node.waitStatus 还没有设置成canceled 。这样也是为了提高性能。shouldParkAfterFailed 中也会删除canceled 的结点。但这两个线程并不存在竟态条件。因为后一个线程止步于当前节点。</span></div><div><br/></div><div>        // predNext is the apparent node to unsplice. CASes below will</div><div>        // fail if not, in which case, we lost race vs another cancel</div><div>        // or signal, so no further action is necessary.</div><div>      <span style="color: rgb(54, 101, 238);">  Node predNext = pred.next;   // 这里为什么要在保留一个本地的值，主要是为了判断程序从当前的点一直到执行compareAndSetNext(pred,  predNext, next) 这个点，如果compareAndSetNext() 执行成功，则在这两点之间执行的操作（依赖predNext 的操作都是正确的。）</span></div><div><br/></div><div>        // Can use unconditional write instead of CAS here.</div><div>        // After this atomic step, other Nodes can skip past us.</div><div>        // Before, we are free of interference from other threads.</div><div>        node.waitStatus = Node.CANCELLED;</div><div><br/></div><div>        // If we are the tail, remove ourselves.</div><div>        <span style="color: rgb(54, 101, 238);">if (node == tail &amp;&amp; compareAndSetTail(node, pred)) { //被cancel 的节点同时是tail  节点， 此时被cancel 的节点是会被删除的。</span></div><div>            compareAndSetNext(pred, predNext, null);</div><div>        } else {  </div><div>            // If successor needs signal, try to set pred's next-link</div><div>            // so it will get one. Otherwise wake it up to propagate.</div><div>            int ws;</div><div>            if (pred != head &amp;&amp;</div><div>                ((ws = pred.waitStatus) == Node.SIGNAL ||</div><div>                 (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;     <span style="color: rgb(54, 101, 238);">//这里考虑到了pred也可能正在执行cancelAcquire操作</span></div><div>                pred.thread != null) {   <span style="color: rgb(54, 101, 238);">//第二种情况下的这个if 语句中， 并没有删除节点，在可能的情况下，设置predNext.next = node.next。</span></div><div>                Node next = node.next;</div><div>                if (next != null &amp;&amp; next.waitStatus &lt;= 0)</div><div>                    compareAndSetNext(pred, predNext, next);</div><div>            } else {</div><div>                <span style="color: rgb(255, 0, 0);">unparkSuccessor(node); // 这里为什么要唤醒线程呢？   注意unparkSuccessor(node) 中的node 上面是的node.thread = null 的，unparkSuccessor() 的作用是找到node 后面的waitStatus &lt;= 0 的节点，这个我上面在Node.thread 用 volatile 修饰的时候解释过了。进入到else 中的场景可能还有其他未考虑到的，但是这里的unparkSuccessor() 的最终的目的都是为了防止出现死锁。从而避免一直等待下去！存在</span></div><div>            }</div><div><br/></div><div>            node.next = node; // help GC</div><div>        }</div><div>    }  </div><div><br/></div><div>ps：   if(pred != head &amp;&amp; ( (ws = pred.waitStatus) == Node.SIGNAL ||  <span style="color: rgb(255, 0, 0);">(ws &lt;= 0 &amp;&amp;  <span style="font-family: 微软雅黑; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: medium; display: inline !important; float: none;">compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</span></span> )) 这里考虑到了在设置compareAndSetWaitStatus() 失败的时候，有两种情况，1： pred 被cancel 了。 2： node.successor 被cancel （这样会产生多余的唤醒操作）。</div><div><span style="color: rgb(255, 0, 0);"><br/></span></div><div><span style="color: rgb(255, 0, 0);"><br/></span></div><div><span style="color: rgb(255, 0, 0);">红色的地方是在什么场景下？ <s>猜测可能是setHeadAndPropagate的时候的场景</s></span></div><div>因为head.successor 节点对应节点的线程会更新head， 因此我们在
<div>if (pred != head &amp;&amp;</div></div><div>                ((ws = pred.waitStatus) == Node.SIGNAL ||</div><div>                 (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; <span style="color: rgb(54, 101, 238);">//被cancel的节点对应的线程在执行到这行代码的时候，可能的情况是pred.waitStatus 可能是0 或者是Node.PROPAGATE（-3），这里compareAndSetNext(pred, predNext, next)是为了提高效率。</span></div><div>                pred.thread != null)</div><div><br/></div><div><br/></div><div><br/></div><div><b>共享模式获取状态</b></div><div><br/></div><div>  public final void acquireShared(int arg) {</div><div>        if (tryAcquireShared(arg) &lt; 0)</div><div>            doAcquireShared(arg);</div><div>    }</div><div><br/></div><div>private void doAcquireShared(int arg) {</div><div>        final Node node = addWaiter(Node.SHARED);</div><div>        boolean failed = true;</div><div>        try {</div><div>            boolean interrupted = false;</div><div>            for (;;) {</div><div>                final Node p = node.predecessor();</div><div>                if (p == head) {</div><div>                    <span style="color: rgb(54, 101, 238);">int r = tryAcquireShared(arg); //tryAcquireShared(arg) 可能同时和新来的线程调用了acquireShared(arg)进行竞争。新来的线程直接执行了acquireShared(arg) 中的tryAcquireShared(arg) 抢先获取了资源。 </span></div><div>                    if (r &gt;= 0) {</div><div>                        setHeadAndPropagate(node, r);</div><div>                        p.next = null; // help GC</div><div>                        if (interrupted)</div><div>                            selfInterrupt();</div><div>                        failed = false;</div><div>                        return;</div><div>                    }</div><div>                }</div><div>                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div>                    parkAndCheckInterrupt())</div><div>                    interrupted = true;</div><div>            }</div><div>        } finally {</div><div>            if (failed)</div><div>                cancelAcquire(node);</div><div>        }</div><div>    }</div><div><br/></div><div>private void setHeadAndPropagate(Node node, int propagate) {</div><div>        Node h = head; // Record old head for check below</div><div>        <span style="color: rgb(54, 101, 238);">setHead(node);   // 在此之前，其他获取共享状态成功的多个线程任务已经执行完了，但是也无法唤醒node 之后的节点的线程。</span></div><div>        /*</div><div>         * Try to signal next queued node if:</div><div>         *   Propagation was indicated by caller,</div><div>         *     or was recorded (as h.waitStatus) by a previous operation</div><div>         *     (note: this uses sign-check of waitStatus because</div><div>         *      PROPAGATE status may transition to SIGNAL.)</div><div>         * and</div><div>         *   The next node is waiting in shared mode,</div><div>         *     or we don't know, because it appears null</div><div>         *</div><div>         * The conservatism in both of these checks may cause</div><div>         * unnecessary wake-ups, but only when there are multiple</div><div>         * racing acquires/releases, so most need signals now or soon</div><div>         * anyway.</div><div>         */</div><div>        <span style="color: rgb(255, 0, 0);">if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0) {   </span><span style="color: rgb(255, 0, 0);">//h == null  出现的场景，GC 回收导致h = null， 因为我们获取不到h.waitStatus 的值的情况。这样做会导致不必要的唤醒， 在multiple racing acquires/releases， so most need signals now or soon anyway。</span></div><div><span style="color: rgb(255, 0, 0);">//h.waitStatus &lt; 0  同上！</span></div><div><span style="color: rgb(255, 0, 0);">//其实这里的核心的目的是为了提高响应性。如下面的tryReleaseShared(arg) 批注的。</span></div><div>            Node s = node.next;</div><div>            if (s == null || s.isShared())</div><div>                doReleaseShared();</div><div>        }</div><div>    }</div><div><br/></div><div><br/></div><div>public final boolean releaseShared(int arg) {</div><div>        <span style="color: rgb(54, 101, 238);">if (tryReleaseShared(arg)) {  // 由于可能有多线程在调用 releaseShared(arg)，  因此，head.successor 节点在进入setHeadAndPropagate(node,  propagate) 的时候，propagate = 0 了，  那么h.waitStatus &lt; 0 的情况下，也是可以调用unparkSuccessor() ，目的是为了提高响应性！！！！</span></div><div>            doReleaseShared();</div><div>            return true;</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div><br/></div><div>private void doReleaseShared() {</div><div>        /*</div><div>         * Ensure that a release propagates, even if there are other</div><div>         * in-progress acquires/releases.  This proceeds in the usual</div><div>         * way of trying to unparkSuccessor of head if it needs</div><div>         * signal. But if it does not, status is set to PROPAGATE to</div><div>         * ensure that upon release, propagation continues.</div><div>         * Additionally, we must loop in case a new node is added</div><div>         * while we are doing this. Also, unlike other uses of</div><div>         * unparkSuccessor, we need to know if CAS to reset status</div><div>         * fails, if so rechecking.</div><div>         */</div><div>        for (;;) {</div><div>            Node h = head;</div><div>            if (h != null &amp;&amp; h != tail) {</div><div>                int ws = h.waitStatus;</div><div>                if (ws == Node.SIGNAL) {</div><div>                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</div><div>                        continue;            // loop to recheck cases</div><div>                    <span style="color: rgb(54, 101, 238);">unparkSuccessor(h);  // 唤醒的线程可能还会由于获取不到状态，而再次进入到  </span></div><div>                }</div><div>                else if (ws == 0 &amp;&amp;</div><div>                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</div><div>                    continue;                // loop on failed CAS</div><div>            }</div><div>            if (h == head)                   // loop if head changed</div><div>                break;</div><div>        }</div><div>    }</div><div><br/></div><div><br/></div><div>共享模式参考Semaphore中的分析。</div><div><br/></div><div>实际上AQS中只维护了队列中的head， tail， 而head  和  tail  中间的各个节点实际上是维护在各个线程中的！！！！！</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 