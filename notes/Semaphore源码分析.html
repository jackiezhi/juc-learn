<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/277915; Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1103"/>

<div>
<span><div>非公平的实现</div><div>public void acquire() throws InterruptedException {</div><div>        sync.acquireSharedInterruptibly(1);   <span style="color: rgb(54, 101, 238);">//AQS中的代码了</span></div><div>    }</div><div><br/></div><div><br/></div><div>public final void acquireSharedInterruptibly(int arg)</div><div>            throws InterruptedException {</div><div>        if (Thread.interrupted())</div><div>            throw new InterruptedException();</div><div>        if (tryAcquireShared(arg) &lt; 0)</div><div>            doAcquireSharedInterruptibly(arg);</div><div>    }</div><div><br/></div><div>protected int tryAcquireShared(int acquires) {</div><div>            return nonfairTryAcquireShared(acquires);</div><div>        }</div><div><br/></div><div>final int nonfairTryAcquireShared(int acquires) { <span style="color: rgb(54, 101, 238);">//Semaphore中的代码</span></div><div>            for (;;) {</div><div>                int available = getState();</div><div>                int remaining = available - acquires;</div><div>                if (remaining &lt; 0 ||</div><div>                    compareAndSetState(available, remaining))</div><div>                    return remaining;</div><div>            }</div><div>        }</div><div><br/></div><div>private void doAcquireSharedInterruptibly(int arg)</div><div>        throws InterruptedException {</div><div>        final Node node = addWaiter(Node.SHARED);</div><div>        boolean failed = true;</div><div>        try {</div><div>            for (;;) {</div><div>                final Node p = node.predecessor();</div><div>                if (p == head) {</div><div>                    int r = tryAcquireShared(arg);</div><div>                    if (r &gt;= 0) {</div><div>                        <span style="color: rgb(54, 101, 238);">setHeadAndPropagate(node, r); //这里setHeadAndPropagate() 只能是由head节点的successor 的情况下才能够调用。</span></div><div>                        p.next = null; // help GC</div><div>                        failed = false;</div><div>                        return;</div><div>                    }</div><div>                }</div><div>                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div>                    parkAndCheckInterrupt())</div><div>                    throw new InterruptedException();</div><div>            }</div><div>        } finally {</div><div>            if (failed)</div><div>                cancelAcquire(node);</div><div>        }</div><div>    }</div><div><br/></div><div>private void setHeadAndPropagate(Node node, int propagate) {</div><div>        Node h = head; // Record old head for check below</div><div>        setHead(node);</div><div>        /*</div><div>         * Try to signal next queued node if:</div><div>         *   Propagation was indicated by caller,</div><div>         *     or was recorded (as h.waitStatus either before</div><div>         *     or after setHead) by a previous operation</div><div>         *     (note: this uses sign-check of waitStatus because</div><div>         *      PROPAGATE status may transition to SIGNAL.)</div><div>         * and</div><div>         *   The next node is waiting in shared mode,</div><div>         *     or we don't know, because it appears null</div><div>         *</div><div>         * The conservatism in both of these checks may cause</div><div>         * unnecessary wake-ups, but only when there are multiple</div><div>         * racing acquires/releases, so most need signals now or soon</div><div>         * anyway.</div><div>         */</div><div>        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</div><div>            (h = head) == null || h.waitStatus &lt; 0) {</div><div>            Node s = node.next;</div><div>            if (s == null || s.isShared())</div><div>                doReleaseShared();</div><div>        }</div><div>    }</div><div><br/></div><div><br/></div><div>public void release() {</div><div>        sync.releaseShared(1);</div><div>    }</div><div><br/></div><div>public final boolean releaseShared(int arg) {</div><div>        if (tryReleaseShared(arg)) {</div><div>            doReleaseShared();</div><div>            return true;</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>private void doReleaseShared() {</div><div>        /*</div><div>         * Ensure that a release propagates, even if there are other</div><div>         * in-progress acquires/releases.  This proceeds in the usual</div><div>         * way of trying to unparkSuccessor of head if it needs</div><div>         * signal. But if it does not, status is set to PROPAGATE to</div><div>         * ensure that upon release, propagation continues.</div><div>         * Additionally, we must loop in case a new node is added</div><div>         * while we are doing this. Also, unlike other uses of</div><div>         * unparkSuccessor, we need to know if CAS to reset status</div><div>         * fails, if so rechecking.</div><div>         */</div><div>        for (;;) {</div><div>            Node h = head;</div><div>            if (h != null &amp;&amp; h != tail) {</div><div>                int ws = h.waitStatus;</div><div>                if (ws == Node.SIGNAL) {</div><div>                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</div><div>                        continue;            // loop to recheck cases</div><div>                    <span style="color: rgb(54, 101, 238);">unparkSuccessor(h);   //release、releaseShared的本质是释放资源，如果有需要唤醒head的后继节点对应的线程</span></div><div>                }</div><div>                else if (ws == 0 &amp;&amp;</div><div>                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</div><div>                    continue;                // loop on failed CAS</div><div>            }</div><div>          <span style="color: rgb(54, 101, 238);">  if (h == head)                   // loop if head changed  //head节点变化，为什么需要继续loop 的目的是为了， head节点变化表明head节点的后继节点对应的线程已经被唤醒了，（因为是共享模式，所以会有多个线程同时执行这段代码） ，这时另一个线程loop 的目的是唤醒新的head的后继节点，从而提高响应性。</span></div><div>                break;</div><div>        }</div><div>    }</div><div><br/></div><div>共享模式的并发场景分析：</div><div>1：多个线程同时修改h.waitStatus的状态时，第一个线程设置head.waitStatus=Node.SIGNAL，同时unparkSuccessor(h)，head.successor 被唤醒从而执行setHeadAndPropagate(node, propagate)， 在执行到tryAcquireShared() 之后， 第二个线程tryReleaseShared() 成功，开始执行doReleaseShared() ，而此时head.successor节点对应的线程，会继续doReleaseShared() .  h == null 的情况是考虑到了GC 的回收，因为在此之前已经setHead() 更新head 了，h 是旧的head 节点引用。</div><div><br/></div><div>2：多个线程同时修改h.waitStatus的状态时，第一个线程设置head.waitStatus=Node.SIGNAL, 同时unparkSuccessor(h),  head.successor 被唤醒从而执行setHeadAndPropagate(node, propagate)， 在执行setHead() 更新head 之前， 第二个线程此时访问到的head 节点上的waitStatus 状态是0， 从而更改waitStatus 为Node.PROPAGATE 状态，head.successor 节点对应的线程执行setHead()，而第二个线程在设置h.waitStatus成功之后，判断head 是否更新，如果更新再loop一遍，目的是为了提高响应性。</div><div><br/></div><div><br/></div><div><br/></div><div>公平的实现</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 